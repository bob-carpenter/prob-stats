# Discrete Random Variables

## Discrete variables and natural numbers

A *random variable* is a variable that can take on different values.
For example, we can represent the result of a coin flip as a random
variable. We can also represent the location on the board of a dart
throw as a random variable.  In statistics, we often reason
*counterfactually* in the sense that we will treat a coin flip that
has already occurred as random.

In this chapter, we explore variables that take on only countably many
values. A *discrete random variable* is one that takes on values that can be
represented as a subset of the *natural numbers*, which we write as
$$
\mathbb{N} = \{ 0, 1, 2, \ldots \}.
$$
Rather than saying the outcome of a coin flip is "heads" or "tails",
we will *code* heads as 1 and tails as 0.

A *finite variable* is a discrete variable whose values can be encoded
using the first $N$ natural numbers, $\{ 0, 1, \ldots, N - 1 \}$, for
some $N \in \mathbb{N}$.  Examples include the result of a coin flip
or of a six-sided die roll. A variable that is not finite is said to be
*infinite*.

## Simulating a fair coin flip

We will start with the canonical "Hello, world!" example for
statistics, flipping a fair coin.

### Stan program for a coin flip

Here's the Stan program for a coin flip.  We title Stan programs in
the book with the file in which they can be found in the source distribution.

##### `flip.stan`
```stan
generated quantities {
  int<lower=0, upper=1> y = bernoulli_rng(0.5);
}
```
Stan is a probabilistic programming language in the sense that its
variables can be random as well as deterministic.  The variable `y`
here is random in that it is assigned the value 1 with probabilty 0.5
and the value 0 with probability 0.5. 

The Stan program `flip.stan` starts with a `generated quantities` block
declaration. The *generated quantities* block is used to generate
random quantities based on other values (here just the constant 0.5).
A Stan *program* is made up of a sequence of blocks, each of which is
made up of a sequence of statements; the other blocks are for data
input, parameters, and model log densities and we will introduce those
later.

The generated quantities block in `flip.stan` contains a single
*statement*, which *declares* the *type* of the *variable* `y` and
also *defines* its value. Every variable in Stan has a single type
that is determined *statically* (i.e., before the program is run). In
this case, the type of `y` is declared to be an integer with the
keyword `int`. The value of `y` is *constrained* to fall between the
specified lower and upper bounds.  The lower and upper bounds are
given by the numeric *literals*, `0` and `1`. The equal sign (`=`) is
used to denote assignment, with the variable `y` being assigned the
value of executing the *expression* `bernoulli_rng(0.5)`. The
expression consists of a *function* `bernoulli_rng` and an argument,
the numeric literal `0.5`. The value of `bernoulli_rng` is random,
returning $1$ with the specified probability of $0.5$ (a $50\%$
chance) and returning $0$ with probability $1 - 0.5$ (also a $50\%$
chance).  The constraint declared on `y` will be validated after the
block's statements are executed; here we know the constraint will
succeed because `bernoulli_rng` only returns 0 or 1 values.


### Executing Stan through Python

We use Python to run the code and show the result of the simulated
coin flip.  First, we are going to import cmdstanpy and then turn off
its intrinsic logger to avoid cluttering our output with feedback
messages intended for the console.

```{python}
#| output: false
from cmdstanpy import CmdStanModel
import logging
cmdstanpy_logger = logging.getLogger("cmdstanpy")
cmdstanpy_logger.disabled = True
```

Next, we compile the Stan model from its source file `flip.stan` using
the constructor for the class `CmdStanModel`.

```{python}
model = CmdStanModel(stan_file = "flip.stan")
```

Next, we use the `sample()` method on the model class to sample values
from the program.

```{python}
fit = model.sample(seed=1234,
                   show_progress=False,
                   show_console = False)
```

With default settings, Stan's sampler simulates a sequence of values
for all of the random variables in the program. The `seed` argument
determines a random seed. If we rerun a Stan program with the same
random seed, we get the same sequence of pseudo-random simulation
values; if we change the seed, the sequence of random numbers changes.
If we do not include a seed, one will be generated automatically based
on the computer's clock.^[This makes it dangerous to call two such
programs in quick succession, for example when multi-threading,
because they may end up with the same time-based seed.]


### Extracting simulated values

From the `fit` object returned by `model.sample()`, we can extract the
sequence of values simulated for the random variables in the program
as a pandas data frame. 

```{python}
draws = fit.draws_pd()
```

Each simulated value is called a *draw*.  We extract the simulated
draws for the variable `y` from the data frame as an array.

```{python}
y_draws = draws['y']
```

For example, here's the result of the first draw.

```{python}
y = y_draws[0]
print(f"first flip = {y:.0f}")
```

A collection of draws makes up what is known as a *sample*.
Continuing past the first simulation, here are the first dozen draws
from the sample.

```{python}
for i in range(12):
    print(f"y({i:d}) = {y_draws[i]:.0f}", end=", ")
    if i == 5: print("")
print("...")
```

We see that some of the simulated values are 1 and some are 0.  The
draws do not correspond to flipping a dozen different coins or even to
flipping the same coin a dozen times in a row.  Instead, the simulated
values represent different possible values for a single flip of a
single coin.


## Simulating a fair die

We can extend the coin example to an example involving dice.  Here's
Stan code to simulate the roll of a fair six-sided die.

`die.stan`
```stan
generated quantities {
  int<lower=1, upper=6> y = categorical_rng(rep_vector(1.0 / 6.0, 6));
}
```

This program places a lower bound of 1 and upper bound of 6
(inclusive) on values.  We simulate values using a categorical
random number generator that assigns a probability of `1 / 6` to each
outcome.^[We write the numbers using decimal notation to avoid
reduction to integer arithmetic, which rounds toward zero.]  Here are
the first 15 draws produced by Stan.

```{python}
#| code-fold: true
model_die = CmdStanModel(stan_file = "die.stan")
fit_die = model_die.sample(seed=1234, show_progress=False, show_console=False)
z = fit_die.draws_pd()["z"]
for i in range(15):
  print(f"z({i:d}) = {z[i]:2.0f}", end=", ")
  if i == 4: print("")
print("...")
```

## Functions on random variables

If $X$ is a random variable and $Y$ is a random variable, then so is
$Z = X + Y$.  We can simulate values for $Z$ by simulating a value for
$X$ and simulating a value for $Y$ and then adding them.  For
instance, if we want the result of rolling two dice, we can do that
with the following Stan program.

`dice.stan`
```stan
generated quantities {
  int<lower=1, upper=6> x = categorical_rng(rep_vector(1.0 / 6.0, 6));
  int<lower=1, upper=6> y = categorical_rng(rep_vector(1.0 / 6.0, 6));
  int<lower=2, upper=12> z = x + y;
}
```

The Stan program defines two variables, `x` and `y`, modeling each as
a fair die, and defines the variable `z` to be their sum.  Here are 25
simulations of `z`.

```{python}
#| code-fold: true
model_dice = CmdStanModel(stan_file = "dice.stan")
fit_dice = model_dice.sample(seed=1234, show_progress=False, show_console=False)
z = fit_dice.draws_pd()["z"]
for i in range(25):
  print(f"z({i:2d}) = {z[i]:2.0f}", end=", ")
  if (i + 1) % 5 == 0: print("")
print("...")
```

While every outcome of throwing a single fair die is equally likely,
this is not true for the sum of two dice.  As you can see from the
example, intermediate outcomes like 7 and 8 occur more frequently than
extreme values like 11 and 12.

## Simulating three dice

We can continue our simulations for rolling three or four dice.  
